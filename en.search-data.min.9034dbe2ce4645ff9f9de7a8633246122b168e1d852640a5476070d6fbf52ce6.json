[{"id":0,"href":"/nspl/docs/usage/","title":"Usage overview","section":"Docs","content":"Creating a plot usually involves 1) getting some data, 2) describing the plot, 3) producing some output in a serialized image format or in a graphics context.\nI. Data sources #  nspl plotting routines take data from org.nspl.data.DataSource subtypes. A DataSource is a lazy collection of vectors of doubles, with definition:\ntrait DataSource { def iterator: Iterator[Row] } trait Row { def apply(i: Int): Double def label: String } For most use cases the import org.nspl._ imports implicit conversions from standard library types like Seq[(Double,Double)] or tuples of other arity.\nThere are a few concrete implementations of a DataSource in the org.nspl.data package like DataTable which is a row major matrix of doubles and DataMatrix which is a raster.\nLazyness #  Nspl is lazy in the data sources. The iterator of the rows of a data source is run only when needed and the rows are only kept in memory where absolute necessary. For example, nspl can render to bitmaps or other raster formats (jpg, png) without accumulating the data rows in memory.\nSaddle data sources #  Saddle is a data manipulation library for Scala, it provides features similar to R\u0026rsquo;s data frames or python\u0026rsquo;s pandas. The \u0026quot;org.nspl\u0026quot; %% \u0026quot;nspl-saddle\u0026quot; % \u0026quot;0.9.0\u0026quot; module has adapters from Saddle data structures to nspl DataSource. Once on the class path you can import it with the import org.nspl.saddle._ wildcard import, and then you can use an org.saddle.Frame everywhere where a DataSource is needed.\nII. Plotting routines #  nspl\u0026rsquo;s API separates the definition of the plot from the actual rendering. First a data structures is created which describes the plot, then that structure is interpreted by a renderer.\nxyplot #  The most important method in nspl\u0026rsquo;s API is the xyplot()() method, a factory for descriptions of 2D plots in a Cartesian coordinate system. It takes two parameter lists: the first parameter list is for data sources and data renderers, the second parameter list is for global plot parameters. Its signature is roughly:\ndef xyplot[F: FC](data: (DataSource, List[DataRenderer], LegendConfig)*)( xlog: Boolean = false, ylog: Boolean = false, main: String = \u0026#34;\u0026#34;, xlab: String = \u0026#34;\u0026#34;, ylab: String = \u0026#34;\u0026#34;, .. many other global plot parameters ..) In the first parameter list of xyplot we give one or more data sources each with zero or more DataRenderer.\nA DataRenderer is visual representation of a row or rows e.g. a point, a line segment, a horizontal or vertical bar, a boxplot, etc. A single data source may have multiple data renderes e.g. both a point and a line segment. For the full list of data renderers see the methods in the Renderers trait.\nThe third element of the triple controls whether the data source is included in the legend or not.\nIn the below example we have a single data source, each row is plotted as a series of consecutive line segments and also as a point. Finally, the data source is included in the legend.\nimport org.nspl._ import org.nspl.awtrenderer._ val someData = List( 0d -\u0026gt; 0d, 1d -\u0026gt; 1d, 2d -\u0026gt; 1d, 3d -\u0026gt; 0d ) val plot = xyplot((someData , List(point(),line()), InLegend(\u0026#34;series 1\u0026#34;)))( par(xlab=\u0026#34;x axis label\u0026#34;, ylab=\u0026#34;y axis label\u0026#34;) ) renderToByteArray(plot, width=2000) The above code block produces this plot: rasterplot #  There is a more specialized factory method for creating a plot from raster (bitmap) type data e.g. to visualize a matrix diretly or draw images. It takes a DataSource with at least three columns, ie. a list of triples: the x, y coordinates and the value. As this is a bitmap the coordinates must fall onto round integers (or they will be rounded down), even though they are stored as doubles.\nAn example with a sparse coordinate list format:\nimport org.nspl._ import org.nspl.awtrenderer._ val sparseMatrix = List( (0d, 0d, 1d), (1d, 1d, 1d), (2d, 2d, 1d), ) val plot2 = rasterplot(sparseMatrix)(par( xlab=\u0026#34;x axis label\u0026#34;, ylab=\u0026#34;y axis label\u0026#34; )) renderToByteArray(plot2.build, width=2000) The above code block produces this plot: An example with a dense matrix:\nimport org.nspl._ import org.nspl.awtrenderer._ import org.nspl.data.DataMatrix import scala.util.Random.nextDouble val denseMatrix = new DataMatrix( rows = Array.fill(12)(nextDouble()), numCols = 4, numRows = 3) val plot3 = rasterplot(denseMatrix)(par( xlab=\u0026#34;x axis label\u0026#34;, ylab=\u0026#34;y axis label\u0026#34; )) renderToByteArray(plot3.build, width=2000) The above code block produces this plot: Box and whiskers plot #  For a box plot you have to first summarize the data distribution into 5 values: median, 25th and 75th percentiles, minimum and maximum. nspl has helper methods to achieve that summary and has a a boxwhisker() data renderer to actually draw the box figure from the summary which is a DataSource with 5 columns.\nThere is also a factory method which does all these in one call:\nimport org.nspl._ import org.nspl.awtrenderer._ import org.nspl.data.DataMatrix import scala.util.Random.nextDouble val randomData1 = 0 until 10 map (_ =\u0026gt; nextDouble()) val randomData2 = 0 until 10 map (_ =\u0026gt; nextDouble()) val randomData = randomData1 zip randomData2 val plotBx = boxplot(randomData)(par()) renderToByteArray(plotBx.build, width=2000) The above code block produces this plot: Note, that these box and whiskers plots do not display individual outlier elements, neither the mean. They display the median, the interquartile range and the minimum and maximum.\nIII. Output formats #  Nspl has different modules depending on the supported graphic context or platform. These modules have methods which take the data structure describing the plot and produce a platform dependent output, e.g. a file, a byte array, or draw to a canvas.\nFor example, as demonstrated in the previous examples, to produce a byte array with a PNG encoded image one can use the org.nspl.awtrenderer.renderToByteArray method:\nimport org.nspl._ import org.nspl.awtrenderer._ val plot = xyplot(..)(..) renderToByteArray(plot.build, width=2000) Similarly, there is an org.nspl.canvasrenderer.render method which returns a new canvas DOM node:\nimport org.nspl._ import org.nspl.canvasrenderer._ val plot = xyplot(..)(..) val (canvas, _) = render(plot) "},{"id":1,"href":"/nspl/imports/","title":"Imports","section":"nspl plotting library","content":"Imports #  Wildcard imports #  If you decide to use wildcard imports then import everthing from the org.nspl package. This will import all the plotting routines, but will not import any platform specific code.\nMost plotting routines need a org.nspl.FontConfiguration instance in the implicit scope. This instance is platform specific, and if you import everything from one of the platform specific packages then this will be imported as well in the scope.\nIn summary, with wildcard imports you need these two imports if using the canvas backend:\nimport org.nspl._ import org.nspl.canvasrenderer._ .. and these two if you use the JVM AWT backend:\nimport org.nspl._ import org.nspl.awtrenderer._ Non-wildcard imports #  If you don\u0026rsquo;t want to pollute the namespace then you can import only the FontConfiguration implicit instance, and prefix every call with its package e.g.\nimport org.nspl import org.nspl.awtrenderer.{defaultGlyphMeasurer, defaultAWTFont} "},{"id":2,"href":"/nspl/docs/datarenderers/","title":"Data renderers","section":"Docs","content":"Data renderers #  Data renderers are implementations of the org.nspl.DataRenderer trait. They create a visual representation from a single data row. Data renderers provide much of the versatility of nspl, for a full you can consult the API documentation.\nData renderers may be combined, as explained in the Usage Overview section.\nIn this section we will use the following data and imports for each code examples:\nimport org.nspl._ import org.nspl.awtrenderer._ // A list of 4-tuples val data = List( (0d, 0d, 0d, 3d), (0.1d, 0.5d, 1d, 5d), (1d, 1d, 2d, 1d), ) // data: List[Tuple4[Double, Double, Double, Double]] = List( // (0.0, 0.0, 0.0, 3.0), // (0.1, 0.5, 1.0, 5.0), // (1.0, 1.0, 2.0, 1.0) // ) point #  Represent each row with a shape placed at the respective coordinate. Size, color, shape are parametrizable and may be data dependent. The point() data renderer needs a DataSource with at least 2 columns (x and y coordinate), but it can use further columns as well for the size, color and shape of the visual representation, but it can use further columns as well for the size, color and shape of the visual representation. It can also append text labels and vertical error bars to the point.\nAn example with triples where the third column (the third element in the triple) is used for the color channel.\nval plot4 = xyplot(data -\u0026gt; point())( par(xlab=\u0026#34;x axis label\u0026#34;, ylab=\u0026#34;y axis label\u0026#34;) ) renderToByteArray(plot4.build, width=2000) The above code block produces this plot: line #  Connects consecutive data rows with lines.\nimport org.nspl._ import org.nspl.awtrenderer._ val plot5 = xyplot(data -\u0026gt; line())( par(xlab=\u0026#34;x axis label\u0026#34;, ylab=\u0026#34;y axis label\u0026#34;) ) renderToByteArray(plot5.build, width=2000) The above code block produces this plot: lineSegment #  This renderer needs at least four columns and draws an indepedent (not necessarily consecutive) line segment from each data row.\nAs there are three rows in the data we defined above this example draws 3 segments:\nimport org.nspl._ import org.nspl.awtrenderer._ val plot6 = xyplot(data -\u0026gt; lineSegment(color = Color.black))( par(xlab=\u0026#34;x axis label\u0026#34;, ylab=\u0026#34;y axis label\u0026#34;) ) renderToByteArray(plot6.build, width=2000) The above code block produces this plot: polynom #  This renderer treats each data row as a polynom which it evaluates numerically at 1000 discrete values over the x-axis. As parameter it takes a secondary data renderer e.g. a point() or a line() to govern the visual representation.\nIn the below example we take the first two element of our list of 4-tuples. This will draw the numeric values of two 4-degree polynom.\nimport org.nspl._ import org.nspl.awtrenderer._ val plot7 = xyplot(data.take(2) -\u0026gt; polynom(() =\u0026gt; line()))( par(xlab=\u0026#34;x axis label\u0026#34;, ylab=\u0026#34;y axis label\u0026#34;, xlim = Some(0d -\u0026gt; 1d), ylim = Some(0d -\u0026gt; 1d)) ) renderToByteArray(plot7.build, width=2000) The above code block produces this plot: bar #  This is the renderer to produce a bar plot. You should not use bar plots.\nimport org.nspl._ import org.nspl.awtrenderer._ val barPlotData = List(1d -\u0026gt; 10d, 2d -\u0026gt; 11d) val plot8 = xyplot( barPlotData -\u0026gt; bar(horizontal=false, width = 0.5, fill = Color.gray2) )( par(xlab=\u0026#34;x axis label\u0026#34;, ylab=\u0026#34;y axis label\u0026#34;, xlim = Some(0d -\u0026gt; 3d)) ) renderToByteArray(plot8.build, width=2000) The above code block produces this plot: boxwhisker #  This is the renderer to produce a box plot. For a box plot you have to first summarize the data distribution into 5 values: median, 25th and 75th percentiles, minimum and maximum.\n"},{"id":3,"href":"/nspl/docs/layouts/","title":"Multi-panel figures","section":"Docs","content":"Layouts and combinators #  Individual plots may be combined into complex figures. This is done by the group() and the sequence() methods. group() turns a tuple of plots into a single plot containing each. sequence() turns a collection (sequence) of plots into a single plot containing each.\nBoth group() and sequence() take multiple arguments and the last argument is an instance of the org.nspl.Layout type. The layout describes how to lay out the individual panels relative to each other. The simplest three layouts are TableLayout(numberOfColumns), HorizontalStack() and VerticalStack(), with these three you can build arbitrary multi-panel figures.\nHere are two plots from a previous example in a single panel:\nimport org.nspl._ import org.nspl.awtrenderer._ import org.nspl.data.DataMatrix import scala.util.Random.nextDouble val sparseMatrix = List( (0d, 0d, 1d), (1d, 1d, 1d), (2d, 2d, 1d), ) val plot1 = rasterplot(sparseMatrix, )(par()) val denseMatrix = new DataMatrix( rows = Array.fill(12)(nextDouble()), numCols = 4, numRows = 3) val plot2 = rasterplot(denseMatrix, )(par()) val complexPlot = group(plot1,plot2,TableLayout(2)) renderToByteArray(complexPlot.build, width=2000) The above code block produces this plot: Or the same with sequence():\nimport org.nspl._ import org.nspl.awtrenderer._ import org.nspl.data.DataMatrix import scala.util.Random.nextDouble val sequencedPlot = sequence(List(plot1,plot2),TableLayout(2)) renderToByteArray(sequencedPlot.build, width=2000) The above code block produces this plot: "},{"id":4,"href":"/nspl/docs/backends/","title":"Output formats","section":"Docs","content":"Nspl has support for the following output formats and platforms:\n The \u0026quot;io.github.pityka\u0026quot; %% \u0026quot;nspl-awt\u0026quot; module works on the JVM and may produce PDF, SVG, EPS, PNG, JPG encoded images or documents, or draws into the interactive Java Graphics2D context). The \u0026quot;io.github.pityka\u0026quot; %%% \u0026quot;nspl-canvas-js\u0026quot; module runs in the browser and can draw onto an interactive html5 canvas. The \u0026quot;io.github.pityka\u0026quot; %%% \u0026quot;scalatags-js\u0026quot; module can produce an SVG image as a DOM subtree (using ScalaTags). The \u0026quot;io.github.pityka\u0026quot; %% \u0026quot;scalatags-jvm\u0026quot; module can produce SVG documents using ScalaTags.  AWT backend (JVM) #  Add this to your build.sbt:\nlibraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;nspl-awt\u0026#34; % \u0026#34;0.9.0\u0026#34; You can use the methods in org.nspl.awtrenderer to produce plots, e.g. pdfToFile, pngToFile, pngToByteArray etc. See this section of the API documentation: awtrenderer object for all the variations of these.\ncanvas backend (Scala.js) #  nspl has a high performance, high quality renderer for the html5 canvas. It can deliver smooth framerates up to several thousand data points. It also has good visual quality, e.g. on high DPI screens we render to an appropriately oversized raster.\nThe rendered plot receives and reacts to mouse events which makes it suitable for interactive use.\nAdd this to your build.sbt:\nlibraryDependencies += \u0026#34;io.github.pityka\u0026#34; %%% \u0026#34;nspl-canvas-js\u0026#34; % \u0026#34;0.9.0\u0026#34; You can use the org.nspl.canvasrenderer.render method to create a new canvas which you can then add to your DOM tree.\nInteractive use (callbacks) #  The backend supports basic user interaction like zooming and panning. The canvas renderer backend draws a few thousand data points with 60fps.\nThe org.nspl.canvasrenderer.render method takes callback which is called whenever the user interacts with the plot on the canvas. Furthermore the render method returns a 2-tuple: the first element is the canvas, the second is a lambda which you can use to update the plot. This lambda takes a renderable element from nspl.\nThe below example renders a plot which forwards events to DOM and receives events from the DOM.\nimport org.nspl._ import org.nspl.canvasrenderer._ import scala.util.Random.nextDouble import org.scalajs.dom.document import org.scalajs.dom.MouseEvent def someData() = 0 until 100 map (_ =\u0026gt; nextDouble() -\u0026gt; nextDouble()) def makePlot() = xyplot(someData())(par()) val logDiv = document.getElementById(\u0026#34;log\u0026#34;) val button = document.getElementById(\u0026#34;button\u0026#34;) .asInstanceOf[org.scalajs.dom.HTMLElement] val (canvas, updatePlotCallback) = render(makePlot(), width = 600, height = 600, click = { clickedPlotElement =\u0026gt; logDiv.textContent = \u0026#34;Plot clicked\u0026#34; } ) val onClick : MouseEvent =\u0026gt; Unit = { (_:MouseEvent) =\u0026gt; updatePlotCallback(makePlot()) } button.onclick = onClick node.appendChild(canvas)  Click me scalatags backends #  The JVM and Scala.js scalatags backends work similarly: you can use the org.nspl.scalatagrenderer.renderToScalaTag method to turn the nspl renderable element into a ScalaTag tree.\nAdd one of these to your build.sbt:\n// for scala.js libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %%% \u0026#34;nspl-scalatags-js\u0026#34; % \u0026#34;0.9.0\u0026#34; // or for the jvm libraryDependencies += \u0026#34;io.github.pityka\u0026#34; %% \u0026#34;nspl-scalatags-jvm\u0026#34; % \u0026#34;0.9.0\u0026#34;   "},{"id":5,"href":"/nspl/docs/gallery/","title":"Plot gallery","section":"Docs","content":"This page lists a diverse collection of plots. They use the PCA of the classical Iris dataset as demo data. To facilitate data manipulation these examples use the Saddle data frame library.\nFirst some utilities and imports:\nimport org.nspl._ import org.nspl.data.HistogramData import org.nspl.saddle._ import org.nspl.awtrenderer._ import org.saddle._ import org.saddle.order._ import org.saddle.csv._ import org.saddle.scalar.ScalarTagDouble import org.saddle.index.InnerJoin def readFrameFromClasspath(s: String) = CsvParser .parseSourceWithHeader[String]( scala.io.Source .fromInputStream( getClass.getResourceAsStream(s) ), recordSeparator = \u0026#34;\\n\u0026#34; ) .toOption .get Next read and parse some data:\nval evec = readFrameFromClasspath(\u0026#34;/evec.csv\u0026#34;).mapValues(ScalarTagDouble.parse) val rotated = readFrameFromClasspath(\u0026#34;/rotated.csv\u0026#34;).mapValues(ScalarTagDouble.parse) val data = readFrameFromClasspath(\u0026#34;/data.csv\u0026#34;) .mapValues(ScalarTagDouble.parse) .colAt(Array(0, 1, 2, 3)) val species = readFrameFromClasspath(\u0026#34;/data.csv\u0026#34;).colAt(4) val spec2Num = species.toVec.toSeq.distinct.sorted.zipWithIndex.toMap val spec: Series[Int, Double] = species.mapValues(spec2Num).mapValues(_.toDouble) val eval = readFrameFromClasspath(\u0026#34;/sqrteigen.csv\u0026#34;) .mapValues(ScalarTagDouble.parse) .mapValues(x =\u0026gt; x * x) val data2 = data.addCol(spec, \u0026#34;spec\u0026#34;, InnerJoin) Plot Gallery #  Scatter plots #  val fig0 = xyplot( data2.col(\u0026#34;Sepal.Length\u0026#34;, \u0026#34;Sepal.Width\u0026#34;, \u0026#34;spec\u0026#34;) )( par(extraLegend = spec2Num.toSeq.map(x =\u0026gt; x._1 -\u0026gt; PointLegend( shape = Shape.rectangle(0, 0, 1, 1), color = DiscreteColors(spec2Num.size)(x._2) ) ), xlab = \u0026#34;Sepal.Length\u0026#34;, ylab = \u0026#34;Sepal.Width\u0026#34;, main = \u0026#34;Iris data\u0026#34;) ) val fig1 = xyplot( Frame( (rotated.col(\u0026#34;PC1\u0026#34;, \u0026#34;PC2\u0026#34;).toColSeq :+ (\u0026#34;spec\u0026#34; -\u0026gt; spec)): _* ) -\u0026gt; point( valueText = true ), density2d( rotated.firstCol(\u0026#34;PC1\u0026#34;).toVec.toSeq zip rotated .firstCol(\u0026#34;PC2\u0026#34;) .toVec .toSeq ) )( par(extraLegend = spec2Num.toSeq.map(x =\u0026gt; x._1 -\u0026gt; PointLegend( shape = Shape.rectangle(0, 0, 1, 1), color = DiscreteColors(spec2Num.size)(x._2) ) ), xlab = \u0026#34;PC1\u0026#34;, ylab = \u0026#34;PC2\u0026#34;, main = \u0026#34;PC1 vs PC2\u0026#34;) ) val scree = xyplot( indexed(eval.firstCol(\u0026#34;x\u0026#34;).toVec.toSeq.sorted.reverse) -\u0026gt; line() )( par(xAxisMargin = 0, xlab = \u0026#34;Order\u0026#34;, ylab = \u0026#34;Eval\u0026#34;, main = \u0026#34;Scree\u0026#34; )) renderToByteArray( group(fig0,fig1,scree,TableLayout(2)).build, width=2000) The above code block produces this plot: Histogram #  val hist1 = xyplot( HistogramData(rotated.firstCol(\u0026#34;PC1\u0026#34;).toVec.toSeq, 10) -\u0026gt; bar() )( par(xlab = \u0026#34;PC1\u0026#34;, ylab = \u0026#34;freq.\u0026#34;, main = \u0026#34;Loading distribution\u0026#34;, ylim = Some(0d, Double.NaN)) ) renderToByteArray(hist1.build,width=2000) The above code block produces this plot: Bar plots #  val bar1 = barplotVertical( Series(\u0026#34;a\u0026#34; -\u0026gt; (-2d), \u0026#34;b\u0026#34; -\u0026gt; (-1d), \u0026#34;c\u0026#34; -\u0026gt; 0d, \u0026#34;d\u0026#34; -\u0026gt; 1d, \u0026#34;e\u0026#34; -\u0026gt; 2d), color = RedBlue(-2, 2) )(par()) val bar2 = barplotHorizontal( Series(\u0026#34;a\u0026#34; -\u0026gt; (-2d), \u0026#34;b\u0026#34; -\u0026gt; (-1d), \u0026#34;c\u0026#34; -\u0026gt; 0d, \u0026#34;d\u0026#34; -\u0026gt; 1d, \u0026#34;e\u0026#34; -\u0026gt; 2d) )(par()) renderToByteArray((group(bar1,bar2,TableLayout(2))).build,width=2000) The above code block produces this plot: Density plot #  val density1 = xyplot( density(rotated.firstCol(\u0026#34;PC1\u0026#34;).toVec.toSeq) -\u0026gt; line( stroke = StrokeConf(1 fts) ) )(par(xlab = \u0026#34;PC1\u0026#34;, ylab = \u0026#34;dens.\u0026#34;, main = \u0026#34;Loading distribution\u0026#34;)) renderToByteArray(density1.build,width=2000) The above code block produces this plot: Raster plot #  import org.nspl.saddle.rasterplotFromFrame val raster1 = rasterplotFromFrame( rotated.rowAt(0 -\u0026gt; 10), yLabFontSize = Some(0.5 fts))(par()) renderToByteArray(raster1.build,width=2000) The above code block produces this plot: Density raster #  val densmap = rasterplot( densityMatrix( rotated.firstCol(\u0026#34;PC1\u0026#34;).toVec.toSeq zip rotated .firstCol(\u0026#34;PC2\u0026#34;) .toVec .toSeq ) )(par()) renderToByteArray(densmap.build,width=2000) The above code block produces this plot: Box plots #  val fig4 = boxplot( data2 .firstCol(\u0026#34;Sepal.Length\u0026#34;) .toVec .toSeq -\u0026gt; data2.firstCol(\u0026#34;Sepal.Width\u0026#34;).toVec.toSeq, xnames = Seq(\u0026#34;Sepal Length\u0026#34;, \u0026#34;Sepal Width\u0026#34;), )(par(ylab = \u0026#34;Sepal Length\u0026#34;, xLabelRotation = -0.3)) val boxpl2 = boxplotFromLabels(List(\u0026#34;a\u0026#34; -\u0026gt; 0d, \u0026#34;a\u0026#34; -\u0026gt; 1d, \u0026#34;b\u0026#34; -\u0026gt; 3d, \u0026#34;b\u0026#34; -\u0026gt; 4d))(par()) renderToByteArray(group(fig4,boxpl2,TableLayout(2)).build,width=2000) The above code block produces this plot: Scatter on log axis #  val logaxis = xyplot( Seq( 1e-6 -\u0026gt; 1e-6, 1e-5 -\u0026gt; 1e-5, 1e-4 -\u0026gt; 1e-4, 1e-3 -\u0026gt; 1e-3, 1e-2 -\u0026gt; 1e-2, 1e-1 -\u0026gt; 1e-1, 1d -\u0026gt; 1d, 10d -\u0026gt; 10d, 1e2 -\u0026gt; 100d, 1e3 -\u0026gt; 1000d, 1e4 -\u0026gt; 10000d, 1e5 -\u0026gt; 1e5, 1e6 -\u0026gt; 1e6, 1e7 -\u0026gt; 1e7 ) -\u0026gt; point() )(par(ylog = true, xlog = true)) renderToByteArray(logaxis.build,width=2000) The above code block produces this plot: "}]